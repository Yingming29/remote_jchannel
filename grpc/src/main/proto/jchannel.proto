syntax = "proto3";
option java_multiple_files = true;
option java_package = "io.grpc.jchannelRpc";
option java_outer_classname = "JChannelRpc";
option objc_class_prefix = "YINGMING";
package cn.yingming.grpc1;

service JChannelsService{
  rpc connect(stream Request) returns (stream Response) {
  }
  rpc ask(ReqAsk) returns (RepAsk) {
  }
}
message Request{
  oneof oneType{
    MessageReq messageRequest = 1;
    ConnectReq connectRequest = 2;
    DisconnectReq disconnectRequest = 3;
    StateReq stateReq = 4;
    StateMsg_withTarget_1 stateMsg1 = 5;
    StateMsg_withTarget_2 stateMsg2 = 6;
    GetAddressReq getAddressReq = 7;
    GetNameReq getNameReq = 8;
    GetClusterNameReq getClusterNameReq = 9;
    PrintProtocolSpecReq printProtoReq = 10;
  }
}
message Response{
  oneof oneType{
    MessageRep messageResponse = 1;
    ConnectRep connectResponse = 2;
    DisconnectRep disconnectResponse = 3;
    UpdateRep updateResponse = 4;  // update available grpc addresses of nodes
    ViewRep viewResponse = 5;   //  JChannel-client view
    ViewRep_server viewRep_server = 6;   // JChannel-server view
    UpdateNameCacheRep updateNameCache = 7;  // update the NameCache of JChannel-server
    StateRep stateRep = 8;
    StateMsg_withTarget_1 stateMsg1 = 9;
    StateMsg_withTarget_2 stateMsg2 = 10;
    GetAddressRep getAddressRep = 11;
    GetNameRep getNameRep = 12;
    GetClusterNameRep getClusterNameRep = 13;
    PrintProtocolSpecRep printProtoRep = 14;
  }
}
message ChannelMsg{
  string type = 1;
  string content_str = 2;
  bytes content_byt = 3;
}
message UpdateReqBetweenNodes{
  bytes address = 1;
}
message UpdateRepBetweenNodes{
  UpdateNameCacheRep nameCache = 1;  // update the existing NameChe, contains JChannel-client and JChannel-server?
  ViewRep clientView = 2;
  StateRep clientState = 3;  // the state (message history) of clients?
}
message UpdateNameCacheRep{
  repeated bytes address = 1;
  repeated string logical_name = 2;
}
message PrintProtocolSpecReq{
  string source = 1;
  string jchannel_address = 2;
  bool include_props = 3;
}
message PrintProtocolSpecRep{
  string protocolStackSpec = 1;

}
message GetClusterNameReq{
  string source = 1;
  string jchannel_address = 2;
}
message GetClusterNameRep{
  string cluster_name = 1;
}
message GetNameReq{
  string source = 1;
  string jchannel_address = 2;
}
message GetNameRep{
  string name = 1;
  string other = 2;
}
message GetAddressReq{
  string source = 1;
  string jchannel_address = 2;
}
message GetAddressRep{
  bytes address = 1;
  bool isWork = 2;
  string other = 3;
}
message ViewRep_server{
  string sender = 1; // string of Address of real JChannel server who sends this View message
  bytes view_byte = 2;
}
message ViewRep{
  bytes view = 1;
}
// update the available servers list
message UpdateRep{
  string addresses = 1;
}
message MessageReq{
  string source = 1;  // uuid
  string jchannel_address = 2;  // the fake address of client jchannel, sender
  string cluster = 3;     // the cluster of jchannel-client
  string content = 4;     // content of message
  string timestamp = 5;   // time
  string destination = 6;  // "" means the broadcast in this cluster, receivers
  bytes contentByte = 7;
}
message MessageRep{
  string jchannel_address = 1; // sender
  string content = 2;
  bytes contentByte = 3;
}
// connect() of JChannel, create a bidirectional streaming of grpc
message ConnectReq {
  string cluster = 1;     // cluster
  string timestamp = 2;
  bool reconnect = 3;         // reconnect and jchannel_address will be used in the reconnection part.
  string jchannel_address = 4;
  string logical_name = 5;
}
// the first time the client connects to the JChannel-server, the server will create an Address and a logical name for it.
//
message ConnectRep {
  bool result = 1;
  bytes address = 2;    // generated Address object's byte
  string logical_name = 3;   // generated Address 'logical name
}

// disconnect()
message DisconnectReq{
  string jchannel_address = 1;
  string cluster = 2;
  string timestamp = 3;
}
message DisconnectRep{
  bool result = 1;
}
// The messages used for the try connection.
message ReqAsk {
  string source = 1;
}
message RepAsk{
  bool survival = 1;
}
message StateReq{
  string source = 1;
  string cluster = 2;
  string jchannel_address = 3;
}

message StateRep{
  int32 size = 1;
  repeated MessageRep oneOfHistory = 2;
}

message StateMsg_withTarget_1{
  string source = 1;
  string cluster = 2;
  string jchannel_address = 3;
  string target = 4;
}

message StateMsg_withTarget_2{
  string source = 1;
  string cluster = 2;
  string jchannel_address = 3;
  repeated MessageRep oneOfHistory = 4;
  string target = 5;
}

